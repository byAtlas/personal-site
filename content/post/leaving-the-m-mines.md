+++
date = "2015-10-08T22:38:13+13:00"
draft = false
title = "Leaving the M$alt Mines"

+++

So a little while ago (ok, a couple of months ago now.) I quit my job at [Ubquity](https://www.ubiquity.co.nz/) in favour of one at [LiveOps](http://www.liveops.com/). There were a bunch of reasons for that, but you'll have to buy me a beer to get those out of me. The main draw though, was being able to work with [Clojure](http://Clojure.org/) instead of C# (Hence the punny title). 

There's a lot of posts about why and how [companies](https://puppetlabs.com/blog/new-era-application-services-puppet-labs) [moved](http://www.pitheringabout.com/?p=693) [to](https://yow.eventer.com/yow-2013-1080/lessons-learned-from-adopting-Clojure-by-jey-fields-1397) [Clojure](http://thoughtworks.github.io/p2/issue09/two-months-early/) but not so many about individuals - I guess we don't really make good marketing pieces? (I'm going to have to eat my hat on this one: [Owen Rees-Hayward](http://owenrh.me.uk/blog/2015/08/24/) totally beat me to the punch.)

So I'm going to tell you a little about why I made the jump to Clojure.

<!--More-->

One of the main reasons I want to use Clojure is selfish - there are terrific productivity gains [promised](http://www.paulgraham.com/avg.html) with any lisp, along with "magic mind expanding powers". By that I mean the claim that it'll make you think about solving problems differently. I'm not certain how much that's happened yet. I know I do code differently, but it's difficult to separate thought patterns from the languages that they're encoded in.

But the point is, anything that makes me a better programmer, or at the very least broadens my skill set, is something I want to try. I've already done that, of course, but there's a big degree of difference between using something for, well, fun basically, and using it in anger. Spending 8 hours a day doing something is probably a pretty good way to get used to wielding it. I already feel just as productive as I was after two years working in C# - I've got a lot of theories about why that is, but that's something I'll save for a later post.

So I've used Clojure in the past, but it's always been dabbling rather than full on commitment - I'd mess with something once every couple of months and then drift off again and forget everything just in time to try and pick it all up again. Clojure wasn't the only programming language I had repeated flings with - I've been bellyaching about my choice of programming language for a while. C# is too verbose, corporate and bland, Go doesn't have enough abstractive power, F# is undersupported (I mean both in the sense of it's corporate master and it's not so super array of libraries), Rust involves too much compiler fighting, ditto Haskell. Yeah. I'm fussy. Even Clojure makes compromises, but at least the choices it makes I can understand (and agree with) the reasoning behind.

Case in point, basing off the JVM. You trade startup time and memory use for a huge ecosystem that's been built up over many, many years, and a stellar virtual machine. (Yes, that's other people's words, I'm not enough of an expert on the JVM to trust my own commentary.) To me, that seems like a pretty good deal. That said, I'm massively hopeful that Clojurescript will prove viable as a serverside lanuguage under node, since it doesn't have the memory footprint or the startup time of the JVM hosted version of Clojure. (This is probably more related to the agressive optimizations that the Closure compiler does, which incurs a hit at compile time as a result.)

That's another thing that's worth mentioning. Don't read this as me bashing on Javascript, because I'd probably pick it as my favourite of any C styled langauge, for a bunch of reasons I won't get into here. It has it's warts (if you haven't seen it yet Gary Bernhardt's ["Javascript Wat" talk](https://www.destroyallsoftware.com/talks/wat) is a great way to witness a few of them in a few minutes.) and when you throw in the general terribleness of a few implementations, it becomes a little unpalatable. Thankfully, there's clojurescript.

Being able to write your front and back end code in the same language with the same semantics is a godsend. I don't get to do a lot of it at work, but not having to make a language context switch every time something needs to get tweaked on the front end is amazing, and having exactly the same data structures shared between the client and the server is really useful. These a whole bunch of pretty amazing libraries and tooling, like figwheel, devcards, and om.

So now it's probably worth discussing the elephant in the room. You know, what normally drives people away from lisps. The parens (also known by their proper name, the parenthesis. But that makes my brain kinda go thunk every time I write it.). All of the parens. Yeah, Clojure has that 'problem'. There's ways to mitigate it (the -> and ->> threading macros, or as I like to call them, the spear and pointy spear.) but you'll still see more ()'s than in say C# or Java.

On the other hand, C# and Java have their own sea of brackets problems, it's just that they tend to be curlier than in Clojure. You also get some chunks in your bracket soup in the form of a ton of keywords. The average Clojure namespace (probably the closest equivalent to a class, and they do compile down to a class, but not as you know it.) doesn't have half the amount of stuff that litters your average java/C#/blub class.

But if you've been working in a language for any length of time, you've probably stopped conciously noticing a whole bunch of things - you don't have to actually look for stuff like the class keyword or the indications that something is a method - you only actually see the names and just kind of know about the surrounding fluff.

The same thing essentially happens in clojure. It's only occasionally that you actually need to go hunting for a stray paren. Rainbow parens and a little bit of bracket match-y highlight-y stuff makes that go away. Or makes the parens you've got too many of go away. There's other tricks as well - Structual editing (aka paredit) seems promising, but also kinda scary. My first encounter with it reminded me of the first time I used vim - mostly an experience of "what the fcsk is going on". That's something I'm going to try and fix, however.

Ok, so that being dealt with, there's one more big draw to clojure (in my opinion, of course. There's lots of other reasons, but I'm just trying to hit the high notes here.) and it's not so much about the language itself as the ecosystem around it, the way it was created, and how that affects the Clojure community. First of all, Rich Hickey gives a lot of very good talks, (you should check them out. It'll make your brain think all different and stuff) and uses a lot of interesting vocabulary. I don't think I've ever heard the term complect uttered by someone who isn't at least a little bit of a functional programming nerd.

It's not the fancy choice of words that really matters, but the stuff behind that - the thinking, and the amount of it that gets done. In spite of the REPL, and the opportunity that gives you to really quickly iterate on your code, the 'best practice' for a working clojurist is to think a lot about problems before you tackle them - Hammock Driven Development (as coined by, you guessed it, Rich.)

It's something that shows elsewhere - in my admittedly thus far limited interaction with the wider Clojure community, I've found people to be a lot more thoughtful and considerate than I've encountered in other communities. That might just be a side-effect of the relatively small size of the community, but I'd like to hope it's something that will persist as more people come into the fold. It's helped make me a lot more comfortable with saying "I don't know" than I was in the past. That probably has something do to with me knowing the response won't be ridicule. And I think it's something that's rubbed off on me a little, which is great. So much of coding is about how you interact with other people, not just in person but through what you produce. Having a little compassion for the people who are going to be suffering through your code later (even if it is going to be you) can only be a good thing.

I know the "Clojure journey" is only really just beginning (doing it for work is completely different to doing it for fun, but I've already said that), but so far it's all promising. It's different to pretty much any other programming language I've worked with, which is making it both interesting and challenging.  There's a pragmatic, considered design that infects anything that touches it. In a good way, mind you. It's gotten into the community, who in my dealings and observations (read: lurking!) are all nice in a way that's pretty uncharateristic of the internet. So yeah. I think I'll be happy here, hopefully for quite some time to come.